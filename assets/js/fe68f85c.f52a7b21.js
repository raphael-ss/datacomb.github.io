"use strict";(self.webpackChunkdatacomb=self.webpackChunkdatacomb||[]).push([[985],{3905:(e,a,o)=>{o.d(a,{Zo:()=>d,kt:()=>k});var t=o(7294);function r(e,a,o){return a in e?Object.defineProperty(e,a,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[a]=o,e}function n(e,a){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),o.push.apply(o,t)}return o}function i(e){for(var a=1;a<arguments.length;a++){var o=null!=arguments[a]?arguments[a]:{};a%2?n(Object(o),!0).forEach((function(a){r(e,a,o[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(o,a))}))}return e}function m(e,a){if(null==e)return{};var o,t,r=function(e,a){if(null==e)return{};var o,t,r={},n=Object.keys(e);for(t=0;t<n.length;t++)o=n[t],a.indexOf(o)>=0||(r[o]=e[o]);return r}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)o=n[t],a.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=t.createContext({}),s=function(e){var a=t.useContext(l),o=a;return e&&(o="function"==typeof e?e(a):i(i({},a),e)),o},d=function(e){var a=s(e.components);return t.createElement(l.Provider,{value:a},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var o=e.components,r=e.mdxType,n=e.originalType,l=e.parentName,d=m(e,["components","mdxType","originalType","parentName"]),p=s(o),u=r,k=p["".concat(l,".").concat(u)]||p[u]||c[u]||n;return o?t.createElement(k,i(i({ref:a},d),{},{components:o})):t.createElement(k,i({ref:a},d))}));function k(e,a){var o=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var n=o.length,i=new Array(n);i[0]=u;var m={};for(var l in a)hasOwnProperty.call(a,l)&&(m[l]=a[l]);m.originalType=e,m[p]="string"==typeof e?e:r,i[1]=m;for(var s=2;s<n;s++)i[s]=o[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,o)}u.displayName="MDXCreateElement"},2603:(e,a,o)=>{o.r(a),o.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>n,metadata:()=>m,toc:()=>s});var t=o(7462),r=(o(7294),o(3905));const n={sidebar_position:1,slug:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",title:"Escopo de Vari\xe1veis e Modelos de Mem\xf3ria"},i="Programa\xe7\xe3o em C: Escopo de Vari\xe1veis e Modelo B\xe1sico de Mem\xf3ria",m={unversionedId:"extras/c-programming/escopo-de-vars-e-memoria",id:"extras/c-programming/escopo-de-vars-e-memoria",title:"Escopo de Vari\xe1veis e Modelos de Mem\xf3ria",description:"Vari\xe1veis",source:"@site/docs/extras/c-programming/escopo-de-vars-e-memoria.md",sourceDirName:"extras/c-programming",slug:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",permalink:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",title:"Escopo de Vari\xe1veis e Modelos de Mem\xf3ria"},sidebar:"tutorialSidebar",previous:{title:"Computa\xe7\xe3o - Programa\xe7\xe3o em C",permalink:"/category/computa\xe7\xe3o---programa\xe7\xe3o-em-c"},next:{title:"Recurs\xe3o",permalink:"/docs/extras/programacao-em-c/recursao"}},l={},s=[{value:"Vari\xe1veis",id:"vari\xe1veis",level:2},{value:"Mem\xf3ria",id:"mem\xf3ria",level:2},{value:"Aloca\xe7\xe3o de Mem\xf3ria em C",id:"aloca\xe7\xe3o-de-mem\xf3ria-em-c",level:2},{value:"Heap x Stack",id:"heap-x-stack",level:3},{value:"Escopo",id:"escopo",level:2},{value:"Conclus\xe3o \ud83c\udf91",id:"conclus\xe3o-",level:2}],d={toc:s},p="wrapper";function c(e){let{components:a,...n}=e;return(0,r.kt)(p,(0,t.Z)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"programa\xe7\xe3o-em-c-escopo-de-vari\xe1veis-e-modelo-b\xe1sico-de-mem\xf3ria"},"Programa\xe7\xe3o em C: Escopo de Vari\xe1veis e Modelo B\xe1sico de Mem\xf3ria"),(0,r.kt)("h2",{id:"vari\xe1veis"},"Vari\xe1veis"),(0,r.kt)("p",null,"Antes de definir os tipos de escopo de vari\xe1veis, precisamos definir o que \xe9 uma vari\xe1vel. Podemos pensar numa vari\xe1vel como um espa\xe7o reservado em mem\xf3ria,\nque cont\xe9m algum dado de algum tipo espec\xedfico. "),(0,r.kt)("p",null,"Veja bem, a a\xe7\xe3o de declarar uma vari\xe1vel pode ser entendida como um pedido por um espa\xe7o em mem\xf3ria para armazenar valores ao longo da execu\xe7\xe3o de um programa, sendo estes valores de um determinado tipo de dado."),(0,r.kt)("p",null,"Nessa defini\xe7\xe3o, percebemos que uma vari\xe1vel possui 2 coisas: um valor armazenado, e uma posi\xe7\xe3o em mem\xf3ria (que pode ser referenciada)."),(0,r.kt)("p",null,"Em C, toda vari\xe1vel precisa ser declarada juntamente com uma especifica\xe7\xe3o de seu tipo, isto \xe9, a defini\xe7\xe3o do tipo de dado da vari\xe1vel declarada.\nCada tipo possui um tamanho pr\xe9-definido a ser alocado em mem\xf3ria. Veja uma tabela:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"variables-in-C",src:o(1769).Z,width:"504",height:"423"})),(0,r.kt)("p",null,"Com essa tabela, podemos ver o n\xb0 de bytes ocupados por cada tipo de C."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"sizeof")),(0,r.kt)("p",{parentName:"admonition"},"Para verificar o tamanho de uma vari\xe1vel ou tipo, pode-se utilizar o operador ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof"),".")),(0,r.kt)("h2",{id:"mem\xf3ria"},"Mem\xf3ria"),(0,r.kt)("p",null,"\xc9 necess\xe1rio, tamb\xe9m, definir o que \xe9 mem\xf3ria. Num computador, a mem\xf3ria \xe9 organizada em c\xe9lulas sequenciais com um n\xb0 determinado de bytes, cada\nc\xe9lula com um endere\xe7o, notado com a base hexadecimal. Veja um esquema:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"memory-cells",src:o(1133).Z,width:"723",height:"456"}),"\n",(0,r.kt)("a",{parentName:"p",href:"http://www.c-jump.com/bcc/c155c/MemAccess/MemAccess.html"},"Fonte da Imagem")),(0,r.kt)("p",null,"No esquema acima, cada c\xe9lula cont\xe9m 1 byte, portanto um inteiro (",(0,r.kt)("em",{parentName:"p"},"int")," de C) ocupa um total de 4 c\xe9lulas. "),(0,r.kt)("p",null,"Existem diferentes tipos de mem\xf3rias num computador, cada tipo com uma velocidade e capacidade diferente. Existem tamb\xe9m mem\xf3rias localizadas em diferentes\nlocais de um computador, como na CPU (registradores, mem\xf3ria cache). Observe o esquema abaixo:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"hierarquia de memoria",src:o(6354).Z,width:"901",height:"403"})),(0,r.kt)("p",null,"Neste esquema, podemos identificar:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Registradores"),":")),(0,r.kt)("p",null,"Mem\xf3ria tempor\xe1ria, de baixa capacidade e super-r\xe1pida usada pelo processador (CPU) no processamento de instru\xe7\xf5es."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Mem\xf3ria ROM/EPROM"),":")),(0,r.kt)("p",null,"Onde ficam armazenadas as instru\xe7\xf5es de inicializa\xe7\xe3o do computador."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Mem\xf3ria Cache"),":")),(0,r.kt)("p",null,"Armazena partes da mem\xf3ria do computador, sendo diretamente endere\xe7\xe1vel pelo processador."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Mem\xf3ria Principal (RAM)"),":")),(0,r.kt)("p",null,"Mem\xf3ria principal do computador, tamb\xe9m diretamente endere\xe7\xe1vel pelo processador."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Mem\xf3ria Secund\xe1ria"),":")),(0,r.kt)("p",null,"Mem\xf3ria de armazenamento permanente (HD, SSD, etc)."),(0,r.kt)("p",null,"Existem outros tipos de mem\xf3ria, por\xe9m esses s\xe3o os mais importantes."),(0,r.kt)("h2",{id:"aloca\xe7\xe3o-de-mem\xf3ria-em-c"},"Aloca\xe7\xe3o de Mem\xf3ria em C"),(0,r.kt)("p",null,"Programando em C, \xe9 importante entender a divis\xe3o da mem\xf3ria em algumas se\xe7\xf5es. Veja:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"memory alloc",src:o(4592).Z,width:"672",height:"417"})),(0,r.kt)("p",null,"Vamos por partes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stack"),":")),(0,r.kt)("p",null,"Cont\xe9m a pilha de execu\xe7\xe3o: mem\xf3ria usada por fun\xe7\xf5es (par\xe2metros, endere\xe7os de retorno, vari\xe1veis locais de fun\xe7\xf5es)\ne alocada estaticamente pelo programador."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Heap"),": ")),(0,r.kt)("p",null,"\xc1rea da mem\xf3ria alocada din\xe2micamente, a pedido do processo."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Static Data, Literals / BSS, DATA"),": ")),(0,r.kt)("p",null,"Armazena vari\xe1veis globais e est\xe1ticas."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Instructions/Text"),":")),(0,r.kt)("p",null,"Cont\xe9m as instru\xe7\xf5es (c\xf3digo) do programa e suas constantes."),(0,r.kt)("h3",{id:"heap-x-stack"},"Heap x Stack"),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"Heap")," \xe9 a \xe1rea de mem\xf3ria utilizada para aloca\xe7\xe3o din\xe2mica. Requer (em C) manuten\xe7\xe3o manual, isto \xe9, o programador precisa desalocar a\nmem\xf3ria alocada. \xc9 a mem\xf3ria global do programa, e \xe9 maior que a Stack (basicamente, do tamanho da mem\xf3ria RAM dispon\xedvel da m\xe1quina)."),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("em",{parentName:"mdxAdmonitionTitle"},"Memory Leak")),(0,r.kt)("p",{parentName:"admonition"},"\xc9 imprescind\xedvel que o programador construa o programa para desalocar corretamente a mem\xf3ria nos devidos locais, isto \xe9, \xe9 obriga\xe7\xe3o do desenvolvedor liberar o espa\xe7o de mem\xf3ria durante a execu\xe7\xe3o do programa.\nN\xe3o fazer isso pode (e provavelmente vai) resultar num ",(0,r.kt)("em",{parentName:"p"},"memory leak"),", ou vazamento de mem\xf3ria. Isso deixa o programa lento, e pode causar erro de execu\xe7\xe3o.")),(0,r.kt)("p",null,"J\xe1 a ",(0,r.kt)("strong",{parentName:"p"},"Stack")," \xe9 funciona como uma 'pilha de fun\xe7\xf5es'. \xc9 a \xe1rea da mem\xf3ria que aloca as vari\xe1eis locais da fun\xe7\xe3o quando uma \xe9 chamada, e funciona\nautomaticamente, ou seja, assim que ocorre o retorno de uma fun\xe7\xe3o, as vari\xe1veis locais e a mem\xf3ria que estava sendo utilizada pela fun\xe7\xe3o s\xe3o destru\xeddas e\ndesalocadas.\nAo longo da execu\xe7\xe3o de um programa, a Stack cresce e diminue de acordo com as chamadas de fun\xe7\xf5es. Por exemplo: se chamarmos uma fun\xe7\xe3o que chama outra fun\xe7\xe3o, as duas ser\xe3o empilhadas na Stack. Retornando da segunda, ela ser\xe1 desalocada, resultando em somente a primeira fun\xe7\xe3o empilhada na Stack. Assim que essa retornar, a Stack ficar\xe1 vazia."),(0,r.kt)("p",null,"Veja esse esquema ilustrativo:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"stack",src:o(9782).Z,width:"694",height:"458"})),(0,r.kt)("admonition",{title:"Tamanho da Stack",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"A Stack \xe9, geralmente, pequena em tamanho, apesar do seu tamanho variar com o SO.\nPor isso, \xe9 importante que sejamos cuidadosos na contru\xe7\xe3o dos programas, por que ultrapassar seu tamanho pode causar estouro da pilha,\nresultando num erro.")),(0,r.kt)("p",null,"\xc9 importante conhecer ambas e saber a diferen\xe7a entre as duas quando se precisar resolver problemas com ponteiros e vazamento de mem\xf3ria."),(0,r.kt)("admonition",{title:"Resumo - Stack x Heap",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Velocidade:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stack"),": mais pr\xf3xima do processador (mais r\xe1pida);"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Heap"),": pode estar na mem\xf3ria principal e ser fragmentada;")))),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Escopo:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stack"),": escopo local;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Heap"),": escopo global;"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Gerenciamento de Mem\xf3ria:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stack"),": mem\xf3ria liberada automaticamente ao t\xe9rmino da fun\xe7\xe3o;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Heap"),": mem\xf3ria deve ser explicitamente liberada pelo desenvolvedor;")))),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Limite de Tamanho:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stack"),": definida pela linguagem e SO;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Heap"),": definida pela quantidade de mem\xf3ria dispon\xedvel;"))))),(0,r.kt)("h2",{id:"escopo"},"Escopo"),(0,r.kt)("p",null,"Pensando num programa como um mapa, o escopo de uma vari\xe1vel \xe9 a regi\xe3o onde ela \xe9 v\xe1lida, isto \xe9, existe e \xe9 referenci\xe1vel. O escopo nada\nmais \xe9 do que um conjunto de regras que determinam o uso e a validade de vari\xe1veis nas diversas partes de um programa."),(0,r.kt)("p",null,"O escopo local \xe9 o escopo comum de uma vari\xe1vel normal, referenci\xe1vel no bloco ou fun\xe7\xe3o onde foi declarada e dura enquanto o bloco durar.\nExistem alguns escopos em C:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vari\xe1vel Global ",(0,r.kt)("inlineCode",{parentName:"li"},"int Global=0;"),":")),(0,r.kt)("p",null,"Referenci\xe1vel em todo o programa. Existe enquanto o programa rodar."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vari\xe1vel Est\xe1tica ",(0,r.kt)("inlineCode",{parentName:"li"},"static int GlobalStatic=0;"),":")),(0,r.kt)("p",null,"Referenci\xe1vel no bloco/fun\xe7\xe3o que foi declarada. Existe durante todo o programa. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vari\xe1vel Externa ",(0,r.kt)("inlineCode",{parentName:"li"},"extern int GlobalExtern=0;"),":")),(0,r.kt)("p",null,"Vari\xe1vel definida em outro arquivo. Referenci\xe1vel em todo o programa. Existe enquanto o programa rodar."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vari\xe1vel Constante ",(0,r.kt)("inlineCode",{parentName:"li"},"const int Constant=3.14;"),":")),(0,r.kt)("p",null,"Pode ser global ou est\xe1tica. Tem valor constante (",(0,r.kt)("em",{parentName:"p"},"read-only"),"), similares ao ",(0,r.kt)("inlineCode",{parentName:"p"},"#define"),"."),(0,r.kt)("p",null,"Veja um exemplo de uso abaixo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n\nint Global = 0;\n\nvoid incrementa() {\n    int local = 0;\n    static int Global_static = 0;\n    printf("Global: %d -- local: %d -- Global_static: %d\\n", Global, local, Global_static);\n    Global++;\n    local++;\n    Global_static++;\n}\n\nint main() {\n    int i;\n    for (i = 0; i < 5; i++) {\n        printf("i: %d --", i);\n        incrementa();\n    }\n\nreturn 0;\n}\n/*** No fim do programa, veremos:\ni: 0 --Global: 0 -- local: 0 -- Global_static: 0\ni: 1 --Global: 1 -- local: 0 -- Global_static: 1\ni: 2 --Global: 2 -- local: 0 -- Global_static: 2\ni: 3 --Global: 3 -- local: 0 -- Global_static: 3\ni: 4 --Global: 4 -- local: 0 -- Global_static: 4\n***/\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"#define")," x ",(0,r.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"const")," "),(0,r.kt)("p",{parentName:"admonition"},"Enquanto o ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),", pareado com uma declara\xe7\xe3o normal de vari\xe1vel, impede o programa (ou o programador) de alterar o valor inicial,\no ",(0,r.kt)("inlineCode",{parentName:"p"},"#define")," toma 2 valores: um 'apelido' e um valor, e na compila\xe7\xe3o, simplesmente substitui todos os locais onde o 'apelido' \xe9 referenciado pelo valor\ndefinido."),(0,r.kt)("p",{parentName:"admonition"},"A diferen\xe7a \xe9 principal \xe9 que o ",(0,r.kt)("inlineCode",{parentName:"p"},"#define")," \xe9 uma diretiva de pr\xe9-processamento, e n\xe3o toma aloca espa\xe7o em mem\xf3ria. J\xe1 a declara\xe7\xe3o de uma\nvari\xe1vel constante com o ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," aloca espa\xe7o em mem\xf3ria."),(0,r.kt)("p",{parentName:"admonition"},"A recomenda\xe7\xe3o \xe9 usar o ",(0,r.kt)("inlineCode",{parentName:"p"},"#define"),", por raz\xf5es de manutenibilidade e mais f\xe1cil leitura e interpreta\xe7\xe3o do c\xf3digo.")),(0,r.kt)("h2",{id:"conclus\xe3o-"},"Conclus\xe3o \ud83c\udf91"),(0,r.kt)("p",null,"Bom, essa se\xe7\xe3o termina aqui.\nCaso tenha alguma d\xfavida que n\xe3o conseguiu encontrar online, envie para ",(0,r.kt)("a",{parentName:"p",href:"mailto:raphaelsoaresbrasil@gmail.com."},"raphaelsoaresbrasil@gmail.com."),"\nObrigado pela aten\xe7\xe3o, e bons estudos."))}c.isMDXComponent=!0},6354:(e,a,o)=>{o.d(a,{Z:()=>t});const t=o.p+"assets/images/hierarquia-de-memoria-fcfb66ae90c1a80624cb315c08ec039e.png"},4592:(e,a,o)=>{o.d(a,{Z:()=>t});const t=o.p+"assets/images/memory-allocation-643bb1098accd4e3476b3444a25d85a5.png"},1133:(e,a,o)=>{o.d(a,{Z:()=>t});const t=o.p+"assets/images/memory_layout-315873b34e6056066d8878a3f19a7639.png"},9782:(e,a,o)=>{o.d(a,{Z:()=>t});const t=o.p+"assets/images/stack-3cd38d4c86c0beab49f5bf176d4e5521.png"},1769:(e,a,o)=>{o.d(a,{Z:()=>t});const t=o.p+"assets/images/variables-in-C-6dc9edd4c386d44051c957876883ea90.png"}}]);