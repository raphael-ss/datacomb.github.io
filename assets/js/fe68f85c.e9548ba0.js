"use strict";(self.webpackChunkdatacomb=self.webpackChunkdatacomb||[]).push([[985],{3905:(e,a,o)=>{o.d(a,{Zo:()=>l,kt:()=>k});var r=o(7294);function t(e,a,o){return a in e?Object.defineProperty(e,a,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[a]=o,e}function i(e,a){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),o.push.apply(o,r)}return o}function n(e){for(var a=1;a<arguments.length;a++){var o=null!=arguments[a]?arguments[a]:{};a%2?i(Object(o),!0).forEach((function(a){t(e,a,o[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(o,a))}))}return e}function m(e,a){if(null==e)return{};var o,r,t=function(e,a){if(null==e)return{};var o,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)o=i[r],a.indexOf(o)>=0||(t[o]=e[o]);return t}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)o=i[r],a.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(t[o]=e[o])}return t}var s=r.createContext({}),d=function(e){var a=r.useContext(s),o=a;return e&&(o="function"==typeof e?e(a):n(n({},a),e)),o},l=function(e){var a=d(e.components);return r.createElement(s.Provider,{value:a},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},u=r.forwardRef((function(e,a){var o=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),c=d(o),u=t,k=c["".concat(s,".").concat(u)]||c[u]||p[u]||i;return o?r.createElement(k,n(n({ref:a},l),{},{components:o})):r.createElement(k,n({ref:a},l))}));function k(e,a){var o=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var i=o.length,n=new Array(i);n[0]=u;var m={};for(var s in a)hasOwnProperty.call(a,s)&&(m[s]=a[s]);m.originalType=e,m[c]="string"==typeof e?e:t,n[1]=m;for(var d=2;d<i;d++)n[d]=o[d];return r.createElement.apply(null,n)}return r.createElement.apply(null,o)}u.displayName="MDXCreateElement"},2603:(e,a,o)=>{o.r(a),o.d(a,{assets:()=>s,contentTitle:()=>n,default:()=>p,frontMatter:()=>i,metadata:()=>m,toc:()=>d});var r=o(7462),t=(o(7294),o(3905));const i={sidebar_position:1,slug:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",title:"Escopo de Vari\xe1veis e Modelos de Mem\xf3ria"},n="Programa\xe7\xe3o em C: Escopo de Vari\xe1veis e Modelo B\xe1sico de Mem\xf3ria",m={unversionedId:"extras/c-programming/escopo-de-vars-e-memoria",id:"extras/c-programming/escopo-de-vars-e-memoria",title:"Escopo de Vari\xe1veis e Modelos de Mem\xf3ria",description:"Vari\xe1veis",source:"@site/docs/extras/c-programming/escopo-de-vars-e-memoria.md",sourceDirName:"extras/c-programming",slug:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",permalink:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"/docs/extras/programacao-em-c/escopo-de-variaveis-e-modelos-de-memoria",title:"Escopo de Vari\xe1veis e Modelos de Mem\xf3ria"},sidebar:"tutorialSidebar",previous:{title:"Computa\xe7\xe3o - Programa\xe7\xe3o em C",permalink:"/category/computa\xe7\xe3o---programa\xe7\xe3o-em-c"},next:{title:"Intro - Extras",permalink:"/docs/extras/intro"}},s={},d=[{value:"Vari\xe1veis",id:"vari\xe1veis",level:2},{value:"Mem\xf3ria",id:"mem\xf3ria",level:2},{value:"Aloca\xe7\xe3o de Mem\xf3ria em C",id:"aloca\xe7\xe3o-de-mem\xf3ria-em-c",level:2},{value:"Heap x Stack",id:"heap-x-stack",level:3}],l={toc:d},c="wrapper";function p(e){let{components:a,...i}=e;return(0,t.kt)(c,(0,r.Z)({},l,i,{components:a,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"programa\xe7\xe3o-em-c-escopo-de-vari\xe1veis-e-modelo-b\xe1sico-de-mem\xf3ria"},"Programa\xe7\xe3o em C: Escopo de Vari\xe1veis e Modelo B\xe1sico de Mem\xf3ria"),(0,t.kt)("h2",{id:"vari\xe1veis"},"Vari\xe1veis"),(0,t.kt)("p",null,"Antes de definir os tipos de escopo de vari\xe1veis, precisamos definir o que \xe9 uma vari\xe1vel. Podemos pensar numa vari\xe1vel como um espa\xe7o reservado em mem\xf3ria,\nque cont\xe9m algum dado de algum tipo espec\xedfico. "),(0,t.kt)("p",null,"Veja bem, a a\xe7\xe3o de declarar uma vari\xe1vel pode ser entendida como um pedido por um espa\xe7o em mem\xf3ria para armazenar valores ao longo da execu\xe7\xe3o de um programa, sendo estes valores de um determinado tipo de dado."),(0,t.kt)("p",null,"Nessa defini\xe7\xe3o, percebemos que uma vari\xe1vel possui 2 coisas: um valor armazenado, e uma posi\xe7\xe3o em mem\xf3ria (que pode ser referenciada)."),(0,t.kt)("p",null,"Em C, toda vari\xe1vel precisa ser declarada juntamente com uma especifica\xe7\xe3o de seu tipo, isto \xe9, a defini\xe7\xe3o do tipo de dado da vari\xe1vel declarada.\nCada tipo possui um tamanho pr\xe9-definido a ser alocado em mem\xf3ria. Veja uma tabela:"),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"variables-in-C",src:o(1769).Z,width:"504",height:"423"})),(0,t.kt)("p",null,"Com essa tabela, podemos ver o n\xb0 de bytes ocupados por cada tipo de C."),(0,t.kt)("admonition",{type:"tip"},(0,t.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,t.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"sizeof")),(0,t.kt)("p",{parentName:"admonition"},"Para verificar o tamanho de uma vari\xe1vel ou tipo, pode-se utilizar o operador ",(0,t.kt)("inlineCode",{parentName:"p"},"sizeof"),".")),(0,t.kt)("h2",{id:"mem\xf3ria"},"Mem\xf3ria"),(0,t.kt)("p",null,"\xc9 necess\xe1rio, tamb\xe9m, definir o que \xe9 mem\xf3ria. Num computador, a mem\xf3ria \xe9 organizada em c\xe9lulas sequenciais com um n\xb0 determinado de bytes, cada\nc\xe9lula com um endere\xe7o, notado com a base hexadecimal. Veja um esquema:"),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"memory-cells",src:o(1133).Z,width:"723",height:"456"}),"\n",(0,t.kt)("a",{parentName:"p",href:"http://www.c-jump.com/bcc/c155c/MemAccess/MemAccess.html"},"Fonte da Imagem")),(0,t.kt)("p",null,"No esquema acima, cada c\xe9lula cont\xe9m 1 byte, portanto um inteiro (",(0,t.kt)("em",{parentName:"p"},"int")," de C) ocupa um total de 4 c\xe9lulas. "),(0,t.kt)("p",null,"Existem diferentes tipos de mem\xf3rias num computador, cada tipo com uma velocidade e capacidade diferente. Existem tamb\xe9m mem\xf3rias localizadas em diferentes\nlocais de um computador, como na CPU (registradores, mem\xf3ria cache). Observe o esquema abaixo:"),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"hierarquia de memoria",src:o(6354).Z,width:"901",height:"403"})),(0,t.kt)("p",null,"Neste esquema, podemos identificar:"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Registradores"),":")),(0,t.kt)("p",null,"Mem\xf3ria tempor\xe1ria, de baixa capacidade e super-r\xe1pida usada pelo processador (CPU) no processamento de instru\xe7\xf5es."),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Mem\xf3ria ROM/EPROM"),":")),(0,t.kt)("p",null,"Onde ficam armazenadas as instru\xe7\xf5es de inicializa\xe7\xe3o do computador."),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Mem\xf3ria Cache"),":")),(0,t.kt)("p",null,"Armazena partes da mem\xf3ria do computador, sendo diretamente endere\xe7\xe1vel pelo processador."),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Mem\xf3ria Principal (RAM)"),":")),(0,t.kt)("p",null,"Mem\xf3ria principal do computador, tamb\xe9m diretamente endere\xe7\xe1vel pelo processador."),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Mem\xf3ria Secund\xe1ria"),":")),(0,t.kt)("p",null,"Mem\xf3ria de armazenamento permanente (HD, SSD, etc)."),(0,t.kt)("p",null,"Existem outros tipos de mem\xf3ria, por\xe9m esses s\xe3o os mais importantes."),(0,t.kt)("h2",{id:"aloca\xe7\xe3o-de-mem\xf3ria-em-c"},"Aloca\xe7\xe3o de Mem\xf3ria em C"),(0,t.kt)("p",null,"Programando em C, \xe9 importante entender a divis\xe3o da mem\xf3ria em algumas se\xe7\xf5es. Veja:"),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"memory alloc",src:o(4592).Z,width:"672",height:"417"})),(0,t.kt)("p",null,"Vamos por partes:"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Stack"),":")),(0,t.kt)("p",null,"Cont\xe9m a pilha de execu\xe7\xe3o: mem\xf3ria usada por fun\xe7\xf5es (par\xe2metros, endere\xe7os de retorno, vari\xe1veis locais de fun\xe7\xf5es)\ne alocada estaticamente pelo programador."),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Heap"),": ")),(0,t.kt)("p",null,"\xc1rea da mem\xf3ria alocada din\xe2micamente, a pedido do processo."),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Static Data, Literals / BSS, DATA"),": ")),(0,t.kt)("p",null,"Armazena vari\xe1veis globais e est\xe1ticas."),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("strong",{parentName:"li"},"Instructions/Text"),":")),(0,t.kt)("p",null,"Cont\xe9m as instru\xe7\xf5es (c\xf3digo) do programa e suas constantes."),(0,t.kt)("h3",{id:"heap-x-stack"},"Heap x Stack"),(0,t.kt)("p",null,"A ",(0,t.kt)("strong",{parentName:"p"},"Heap")," \xe9 a \xe1rea de mem\xf3ria utilizada para aloca\xe7\xe3o din\xe2mica. Requer (em C) manuten\xe7\xe3o manual, isto \xe9, o programador precisa desalocar a\nmem\xf3ria alocada. \xc9 a mem\xf3ria global do programa, e \xe9 maior que a Stack (basicamente, do tamanho da mem\xf3ria RAM dispon\xedvel da m\xe1quina)."),(0,t.kt)("admonition",{type:"danger"},(0,t.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,t.kt)("em",{parentName:"mdxAdmonitionTitle"},"Memory Leak")),(0,t.kt)("p",{parentName:"admonition"},"\xc9 imprescind\xedvel que o programador construa o programa para desalocar corretamente a mem\xf3ria nos devidos locais, isto \xe9, \xe9 obriga\xe7\xe3o do desenvolvedor liberar o espa\xe7o de mem\xf3ria durante a execu\xe7\xe3o do programa.\nN\xe3o fazer isso pode (e provavelmente vai) resultar num ",(0,t.kt)("em",{parentName:"p"},"memory leak"),", ou vazamento de mem\xf3ria. Isso deixa o programa lento, e pode causar erro de execu\xe7\xe3o.")),(0,t.kt)("p",null,"J\xe1 a ",(0,t.kt)("strong",{parentName:"p"},"Stack")," \xe9 funciona como uma 'pilha de fun\xe7\xf5es'. \xc9 a \xe1rea da mem\xf3ria que aloca as vari\xe1eis locais da fun\xe7\xe3o quando uma \xe9 chamada, e funciona\nautomaticamente, ou seja, assim que ocorre o retorno de uma fun\xe7\xe3o, as vari\xe1veis locais e a mem\xf3ria que estava sendo utilizada pela fun\xe7\xe3o s\xe3o destru\xeddas e\ndesalocadas.\nAo longo da execu\xe7\xe3o de um programa, a Stack cresce e diminue de acordo com as chamadas de fun\xe7\xf5es. Por exemplo: se chamarmos uma fun\xe7\xe3o que chama outra fun\xe7\xe3o, as duas ser\xe3o empilhadas na Stack. Retornando da segunda, ela ser\xe1 desalocada, resultando em somente a primeira fun\xe7\xe3o empilhada na Stack. Assim que essa retornar, a Stack ficar\xe1 vazia."),(0,t.kt)("p",null,"Veja esse esquema ilustrativo:"),(0,t.kt)("p",null,"!(stack)","[/img/stack.png]"),(0,t.kt)("admonition",{title:"Tamanho da Stack",type:"caution"},(0,t.kt)("p",{parentName:"admonition"},"A Stack \xe9, geralmente, pequena em tamanho, apesar do seu tamanho variar com o SO.\nPor isso, \xe9 importante que sejamos cuidadosos na contru\xe7\xe3o dos programas, por que ultrapassar seu tamanho pode causar estouro da pilha,\nresultando num erro.")))}p.isMDXComponent=!0},6354:(e,a,o)=>{o.d(a,{Z:()=>r});const r=o.p+"assets/images/hierarquia-de-memoria-fcfb66ae90c1a80624cb315c08ec039e.png"},4592:(e,a,o)=>{o.d(a,{Z:()=>r});const r=o.p+"assets/images/memory-allocation-643bb1098accd4e3476b3444a25d85a5.png"},1133:(e,a,o)=>{o.d(a,{Z:()=>r});const r=o.p+"assets/images/memory_layout-315873b34e6056066d8878a3f19a7639.png"},1769:(e,a,o)=>{o.d(a,{Z:()=>r});const r=o.p+"assets/images/variables-in-C-6dc9edd4c386d44051c957876883ea90.png"}}]);